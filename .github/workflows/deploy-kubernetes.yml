name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: ms-feedback
  NAMESPACE: ms-feedback

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube (manual installation)
        run: |
          echo "ğŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          echo "ğŸš€ Starting Minikube..."
          minikube start --driver=docker --memory=4096 --cpus=2 --kubernetes-version=v1.28.0
          
          echo "â³ Waiting for Minikube to be ready..."
          minikube status
          
          echo "âœ… Minikube started successfully"

      - name: Configure kubectl
        run: |
          echo "ğŸ”§ Configuring kubectl..."
          kubectl config use-context minikube
          kubectl config view
          
          echo "âœ… kubectl configured"

      - name: Verify Minikube
        run: |
          echo "ğŸ” Cluster info:"
          kubectl cluster-info
          
          echo "ğŸ“Š Nodes:"
          kubectl get nodes
          
          echo "ğŸ³ Docker env:"
          minikube docker-env

      - name: Load Docker image into Minikube
        run: |
          echo "ğŸ“¥ Loading Docker image into Minikube..."
          minikube image load app-image.tar
          
          echo "ğŸ·ï¸ Tagging image inside Minikube..."
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "ğŸ“‹ Images inside Minikube:"
          minikube image ls | grep ${{ env.IMAGE_NAME }} || echo "âš ï¸  Image not found yet, will retry..."
          
          echo "âœ… Image loaded and tagged successfully"

      - name: Pull and Load MS-Persistance image
        run: |
          echo "ğŸ“¥ Pulling MS-Persistance image directly into Minikube..."
          eval $(minikube -p minikube docker-env)
          docker pull abdboutchichi/ms-persistance:latest
          echo "ğŸ” Verifying MS-Persistance image in Minikube..."
          docker images | grep ms-persistance || { echo "âŒ ms-persistance image not found"; exit 1; }
          echo "âœ… MS-Persistance image successfully loaded into Minikube"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace created/verified"

      - name: Deploy application to Minikube
        run: |
          echo "ğŸš€ Deploying manifests..."
          kubectl apply -f k8s/minikube/persistance.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "ğŸ“Š Current deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo "âœ… Manifests applied (ms-persistance + ms-feedback)"

      - name: Wait for pods to be created
        run: |
          echo "â³ Waiting 15 seconds for pods to be created..."
          sleep 15
          
          echo "ğŸ“Š Current state:"
          kubectl get all -n ${{ env.NAMESPACE }}

      - name: Wait for MySQL to be ready
        run: |
          echo "â³ Waiting for MySQL to be ready (max 120s)..."
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=120s || {
            echo "âŒ MySQL not ready!"
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=mysql
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          echo "âœ… MySQL is ready!"

      - name: Deploy phpMyAdmin
        run: |
          echo "ğŸ¬ Deploying phpMyAdmin..."
          kubectl apply -f k8s/minikube/phpmyadmin.yaml -n ${{ env.NAMESPACE }}
          
          echo "â³ Waiting for phpMyAdmin to be ready..."
          kubectl wait --for=condition=ready pod -l app=phpmyadmin -n ${{ env.NAMESPACE }} --timeout=60s || {
            echo "âš ï¸ phpMyAdmin not ready, but continuing..."
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=phpmyadmin
          }
          echo "âœ… phpMyAdmin deployed!"

      - name: Debug pods before rollout
        if: always()
        run: |
          echo "ğŸ” Current pods status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "ğŸ” ms-feedback pods details:"
          kubectl describe pods -l app=ms-feedback -n ${{ env.NAMESPACE }} || echo "No ms-feedback pods yet"
          
          echo ""
          echo "ğŸ” Recent events:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' --field-selector type!=Normal | tail -20 || echo "No error events"

      - name: Wait for deployment
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/ms-feedback -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "âŒ Rollout timeout! Gathering debug info..."
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }}
            kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          
          echo "âœ… Deployment successful"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide

      - name: Get service endpoint
        id: endpoint
        run: |
          kubectl wait --for=condition=ready pod -l app=ms-feedback -n ${{ env.NAMESPACE }} --timeout=300s
          SERVICE_URL=$(minikube service ms-feedback --url -n ${{ env.NAMESPACE }} 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            MINIKUBE_IP=$(minikube ip)
            NODEPORT=$(kubectl get svc ms-feedback -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
            SERVICE_URL="http://$MINIKUBE_IP:$NODEPORT"
          fi
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service accessible at: $SERVICE_URL"

      - name: Test service health
        run: |
          echo "ğŸ¥ Testing service health..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          # Attendre que le service soit vraiment prÃªt
          for i in {1..12}; do
            if curl -f --connect-timeout 5 "$SERVICE_URL/actuator/health" 2>/dev/null; then
              echo "âœ… Service is healthy!"
              break
            fi
            echo "â³ Waiting for service to be fully ready ($i/12)..."
            sleep 5
          done
          
          # Test final
          curl -f "$SERVICE_URL/actuator/health" || \
          curl -f "$SERVICE_URL/health" || \
          curl -f "$SERVICE_URL/" || {
            echo "âŒ Health check failed"
            kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=50
            exit 1
          }
          
          echo "âœ… Service is healthy and ready for tests"

      - name: Install Newman for integration tests
        working-directory: ./tests/newman
        run: |
          echo "ğŸ“¦ Installing Newman dependencies..."
          npm install
          echo "âœ… Newman installed"

      - name: Configure Newman environment
        working-directory: ./tests/newman
        run: |
          echo "ğŸ“ Configuring Newman with service URL..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          # Compute MS-Persistance URL (NodePort 30090)
          MINIKUBE_IP=$(echo $SERVICE_URL | sed -E 's|http://([^:]+):.*|\1|')
          PERSISTANCE_URL="http://${MINIKUBE_IP}:30090"
          echo "ğŸ”— ms-feedback URL: $SERVICE_URL"
          echo "ğŸ”— ms-persistance URL: $PERSISTANCE_URL"
          
          jq --arg url "$SERVICE_URL" --arg purl "$PERSISTANCE_URL" \
            '(.values[] | select(.key == "baseUrl") | .value) = $url |
             (.values[] | select(.key == "persistanceUrl") | .value) = $purl' \
            env.json > env.tmp.json
          
          echo "ğŸ“‹ Environment configuration:"
          cat env.tmp.json | jq '.'
          echo "âœ… Environment configured with URLs"

      - name: Run Newman integration tests
        working-directory: ./tests/newman
        run: |
          echo "ğŸš€ Starting Newman integration tests..."
          echo "ğŸ¯ Target: ${{ steps.endpoint.outputs.service_url }}"
          
          mkdir -p newman-results
          
          npx newman run ./collection.json \
            --environment ./env.tmp.json \
            --iteration-data ./dataset.json \
            --reporters cli,json \
            --reporter-json-export ./newman-results/newman-report.json \
            --timeout-request 30000 \
            --bail || {
              echo "âŒ Newman tests failed!"
              echo ""
              echo "ğŸ“Š Service status:"
              curl -v "${{ steps.endpoint.outputs.service_url }}/actuator/health" || true
              echo ""
              echo "ğŸ“‹ Pod logs:"
              kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=100
              exit 1
            }
          
          echo ""
          echo "âœ… All Newman tests passed successfully!"

      - name: Upload Newman results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-results
          path: tests/newman/newman-results/
          retention-days: 7

      - name: Upload service URL artifact
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 1

      - name: Seed data in MS-Persistance (user + recipe)
        run: |
          echo "ğŸŒ± Seeding data in ms-persistance..."
          MINIKUBE_IP=$(minikube ip)
          PERSISTANCE_URL="http://${MINIKUBE_IP}:30090"
          echo "ğŸ”— Using ms-persistance: $PERSISTANCE_URL"

          # Create user if not exists (ID=1)
          echo "ğŸ‘¤ Ensuring user #1 exists"
          if ! curl -sf "$PERSISTANCE_URL/api/persistance/utilisateurs/1" >/dev/null; then
            echo "â¡ï¸ Creating user #1"
            curl -sf -X POST "$PERSISTANCE_URL/api/persistance/utilisateurs" \
              -H 'Content-Type: application/json' \
              -d '{"id":1, "nom":"Test", "prenom":"User", "email":"user1@example.com"}' || {
                echo "âŒ Failed to create user #1"; exit 1; }
          else
            echo "âœ… User #1 already exists"
          fi

          # Create recipe if not exists (ID=5)
          echo "ğŸ½ï¸ Ensuring recipe #5 exists"
          if ! curl -sf "$PERSISTANCE_URL/api/persistance/recettes/5" >/dev/null; then
            echo "â¡ï¸ Creating recipe #5"
            curl -sf -X POST "$PERSISTANCE_URL/api/persistance/recettes" \
              -H 'Content-Type: application/json' \
              -d '{"id":5, "titre":"Recette test", "description":"Recette de dÃ©monstration", "categorie":"TEST"}' || {
                echo "âŒ Failed to create recipe #5"; exit 1; }
          else
            echo "âœ… Recipe #5 already exists"
          fi

          # Verify both exist
          curl -sf "$PERSISTANCE_URL/api/persistance/utilisateurs/1" >/dev/null || { echo "âŒ User #1 not found after creation"; exit 1; }
          curl -sf "$PERSISTANCE_URL/api/persistance/recettes/5"     >/dev/null || { echo "âŒ Recipe #5 not found after creation"; exit 1; }
          echo "âœ… Data seeding completed"
