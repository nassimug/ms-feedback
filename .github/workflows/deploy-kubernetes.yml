name: CD - Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        type: string
      microservice-name:
        description: 'Microservice name'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag'
        required: true
        type: string
    secrets:
      OCI_KUBECONFIG:
        required: true
      OKE_CLUSTER_ID:
        required: false
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      MYSQL_HOST:
        required: false
      MYSQL_USER:
        required: false
      MYSQL_PASSWORD:
        required: false
      MYSQL_ROOT_PASSWORD:
        required: false
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - integration
          - production
        default: integration
      image-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: BACKEND_ENVIRONMENT
    env:
      NAMESPACE: ${{ inputs.namespace }}
      MICROSERVICE_NAME: ${{ inputs.microservice-name }}
      IMAGE_TAG: ${{ inputs.image-tag }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION || 'eu-paris-1' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          mkdir -p ~/.kube
          
          
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√© depuis OCI_KUBECONFIG"
          
          echo "Informations du cluster:"
          CLUSTER_SERVER=$(grep 'server:' ~/.kube/config | head -1 | awk '{print $2}' | sed 's/https:\/\///')
          echo "  Server: $CLUSTER_SERVER"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          echo "V√©rification du namespace '${{ env.NAMESPACE }}'..."
          
          if kubectl get namespace "${{ env.NAMESPACE }}" &> /dev/null; then
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '${{ env.NAMESPACE }}'..."
            kubectl create namespace "${{ env.NAMESPACE }}"
            kubectl label namespace "${{ env.NAMESPACE }}" environment=${{ inputs.environment }}
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' cr√©√©"
          fi

      - name: Create or Update Secrets
        run: |
          echo "Configuration des secrets..."
          
          # Variables pour le secret OCIR
          DOCKER_SERVER="cdg.ocir.io"
          DOCKER_USERNAME="${{ secrets.OCI_TENANCY_NAMESPACE }}/${{ secrets.OCI_USERNAME }}"
          DOCKER_PASSWORD="${{ secrets.OCI_AUTH_TOKEN }}"
          
          echo "Registry: $DOCKER_SERVER"
          echo "Username: ${DOCKER_USERNAME%%/*}/***"
          
          # V√©rifier que les variables sont d√©finies
          if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_PASSWORD" ]; then
            echo "‚ùå Erreur: OCI_TENANCY_NAMESPACE, OCI_USERNAME ou OCI_AUTH_TOKEN manquant"
            exit 1
          fi
          
          # Secret OCIR
          kubectl create secret docker-registry ocir-secret \
            --docker-server="$DOCKER_SERVER" \
            --docker-username="$DOCKER_USERNAME" \
            --docker-password="$DOCKER_PASSWORD" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secret OCIR configur√©"
          
          # Secret MySQL
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets MySQL configur√©s"

      - name: Create or Update ConfigMap
        run: |
          echo "Configuration de la ConfigMap..."
          
          SPRING_PROFILE="${{ inputs.environment }}"
          LOG_LEVEL="DEBUG"
          LOG_LEVEL_JDBC="DEBUG"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE="$SPRING_PROFILE" \
            --from-literal=LOG_LEVEL="$LOG_LEVEL" \
            --from-literal=LOG_LEVEL_JDBC="$LOG_LEVEL_JDBC" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap configur√©e"

      - name: Verify Docker Image Exists
        run: |
          echo "V√©rification de l'existence de l'image Docker..."
          
          # Sanitiser le nom du microservice
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/$MICROSERVICE_NAME_SANITIZED:${{ env.IMAGE_TAG }}"
          
          echo "Image √† v√©rifier: $IMAGE_URL"
          
          # V√©rifier que l'image existe dans OCIR
          if docker manifest inspect "$IMAGE_URL" > /dev/null 2>&1; then
            echo "‚úÖ Image trouv√©e dans OCIR"
          else
            echo ""
            echo "‚ùå ERREUR: L'image n'existe pas dans OCIR!"
            echo ""
            echo "Image recherch√©e: $IMAGE_URL"
            echo ""
            echo "Causes possibles:"
            echo "1. Le job 'build-docker-image' a √©chou√©"
            echo "2. Le repository 'smartdish/$MICROSERVICE_NAME_SANITIZED' n'existe pas dans OCIR"
            echo "3. Le tag '${{ env.IMAGE_TAG }}' n'a pas √©t√© cr√©√©"
            echo ""
            echo "Actions √† faire:"
            echo "1. V√©rifiez que le job 'build-docker-image' a r√©ussi"
            echo "2. Cr√©ez le repository dans OCIR: Console OCI > Container Registry > Create Repository"
            echo "   - Name: smartdish/$MICROSERVICE_NAME_SANITIZED"
            echo "   - Access: Private"
            echo "3. Relancez le workflow"
            echo ""
            exit 1
          fi

      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Sanitiser le nom du microservice (remplacer les points par des tirets)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          # Variables pour le template
          export MICROSERVICE_NAME="$MICROSERVICE_NAME_SANITIZED"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export VERSION="${{ env.IMAGE_TAG }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          export IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/$MICROSERVICE_NAME_SANITIZED"
          
          # D√©terminer le nombre de replicas selon l'environnement
          if [ "${{ inputs.environment }}" == "production" ]; then
            export REPLICAS=2
          else
            export REPLICAS=1
          fi
          
          echo "Configuration du d√©ploiement:"
          echo "  - Microservice original: ${{ env.MICROSERVICE_NAME }}"
          echo "  - Microservice sanitized: $MICROSERVICE_NAME_SANITIZED"
          echo "  - Namespace: $NAMESPACE"
          echo "  - Image: $IMAGE_URL:$IMAGE_TAG"
          echo "  - Replicas: $REPLICAS"
          
          # G√©n√©rer et appliquer le d√©ploiement
          envsubst < k8s/oci/deployment-template.yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          # Sanitiser le nom du microservice (m√™me transformation)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          kubectl rollout status deployment/$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --tail=50 || true
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment $MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }}
            exit 1
          }
          
          echo "‚úÖ D√©ploiement termin√© avec succ√®s"

      - name: Display Deployment Info
        run: |
          # Sanitiser le nom du microservice (m√™me transformation)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Microservice original: ${{ env.MICROSERVICE_NAME }}"
          echo "üè∑Ô∏è  Microservice sanitized: $MICROSERVICE_NAME_SANITIZED"
          echo "üè∑Ô∏è  Image: cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/$MICROSERVICE_NAME_SANITIZED:${{ env.IMAGE_TAG }}"
          echo "üåç Namespace: ${{ env.NAMESPACE }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n ${{ env.NAMESPACE }} -l app=$MICROSERVICE_NAME_SANITIZED
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=$MICROSERVICE_NAME_SANITIZED
          echo ""
          echo "=========================================="
          echo "üìù LOGS DES PODS (derni√®res 20 lignes)"
          echo "=========================================="
          kubectl logs -l app=$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --tail=20 || true
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi