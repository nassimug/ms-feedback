name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: univ-soa
  NAMESPACE: soa-integration

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube (manual installation)
        run: |
          echo "ğŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          echo "ğŸš€ Starting Minikube..."
          minikube start --driver=docker --memory=4096 --cpus=2 --kubernetes-version=v1.28.0
          
          echo "â³ Waiting for Minikube to be ready..."
          minikube status
          
          echo "âœ… Minikube started successfully"

      - name: Configure kubectl
        run: |
          echo "ğŸ”§ Configuring kubectl..."
          kubectl config use-context minikube
          kubectl config view
          
          echo "âœ… kubectl configured"

      - name: Verify Minikube
        run: |
          echo "ğŸ” Cluster info:"
          kubectl cluster-info
          
          echo "ğŸ“Š Nodes:"
          kubectl get nodes
          
          echo "ğŸ³ Docker env:"
          minikube docker-env

      - name: Load Docker image into Minikube
        run: |
          echo "ğŸ“¥ Loading Docker image into Minikube..."
          minikube image load app-image.tar
          
          echo "ğŸ·ï¸ Tagging image inside Minikube..."
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "ğŸ“‹ Images inside Minikube:"
          minikube image ls | grep ${{ env.IMAGE_NAME }} || echo "âš ï¸  Image not found yet, will retry..."
          
          echo "âœ… Image loaded and tagged successfully"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace created/verified"

      - name: Deploy application to Minikube
        run: |
          echo "ğŸš€ Deploying manifests..."
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "ğŸ“Š Current deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo "âœ… Manifests applied (using image: univ-soa:latest)"

      - name: Wait for pods to be created
        run: |
          echo "â³ Waiting 15 seconds for pods to be created..."
          sleep 15
          
          echo "ğŸ“Š Current state:"
          kubectl get all -n ${{ env.NAMESPACE }}

      - name: Wait for MySQL to be ready
        run: |
          echo "â³ Waiting for MySQL to be ready (max 120s)..."
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=120s || {
            echo "âŒ MySQL not ready!"
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=mysql
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          echo "âœ… MySQL is ready!"

      - name: Deploy phpMyAdmin
        run: |
          echo "ğŸ¬ Deploying phpMyAdmin..."
          kubectl apply -f k8s/minikube/phpmyadmin.yaml -n ${{ env.NAMESPACE }}
          
          echo "â³ Waiting for phpMyAdmin to be ready..."
          kubectl wait --for=condition=ready pod -l app=phpmyadmin -n ${{ env.NAMESPACE }} --timeout=60s || {
            echo "âš ï¸ phpMyAdmin not ready, but continuing..."
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=phpmyadmin
          }
          echo "âœ… phpMyAdmin deployed!"

      - name: Debug pods before rollout
        if: always()
        run: |
          echo "ğŸ” Current pods status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "ğŸ” univ-soa pods details:"
          kubectl describe pods -l app=univ-soa -n ${{ env.NAMESPACE }} || echo "No univ-soa pods yet"
          
          echo ""
          echo "ğŸ” Recent events:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' --field-selector type!=Normal | tail -20 || echo "No error events"

      - name: Wait for deployment
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/univ-soa -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "âŒ Rollout timeout! Gathering debug info..."
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }}
            kubectl logs -l app=univ-soa -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          
          echo "âœ… Deployment successful"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide

      - name: Get service endpoint
        id: endpoint
        run: |
          kubectl wait --for=condition=ready pod -l app=univ-soa -n ${{ env.NAMESPACE }} --timeout=300s
          SERVICE_URL=$(minikube service univ-soa --url -n ${{ env.NAMESPACE }} 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            MINIKUBE_IP=$(minikube ip)
            NODEPORT=$(kubectl get svc univ-soa -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
            SERVICE_URL="http://$MINIKUBE_IP:$NODEPORT"
          fi
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service accessible at: $SERVICE_URL"

      - name: Test service health
        run: |
          curl -f ${{ steps.endpoint.outputs.service_url }}/actuator/health || \
          curl -f ${{ steps.endpoint.outputs.service_url }}/health || \
          curl -f ${{ steps.endpoint.outputs.service_url }}/ || \
          echo "Health check endpoint not available"

      - name: Upload service URL artifact
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 1

  expose-services:
    name: ğŸŒ Expose Services URLs
    runs-on: ubuntu-latest
    needs: [deploy]
    env:
      NAMESPACE: soa-integration
    steps:
      - name: Setup Minikube
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          kubernetes-version: 'v1.28.0'
          driver: 'docker'
          cpus: 2
          memory: 4096
          addons: ingress

      - name: Get all service URLs
        id: services
        run: |
          echo "ğŸ” Getting service URLs..."
          MINIKUBE_IP=$(minikube ip)
          
          # Get API service
          API_NODEPORT=$(kubectl get svc univ-soa -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
          API_URL="http://$MINIKUBE_IP:$API_NODEPORT"
          
          # Get phpMyAdmin service
          PHPMYADMIN_NODEPORT=$(kubectl get svc phpmyadmin -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' || echo "30081")
          PHPMYADMIN_URL="http://$MINIKUBE_IP:$PHPMYADMIN_NODEPORT"
          
          # Get MySQL service (internal only)
          MYSQL_HOST="mysql.${{ env.NAMESPACE }}.svc.cluster.local"
          
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "phpmyadmin_url=$PHPMYADMIN_URL" >> $GITHUB_OUTPUT
          echo "mysql_host=$MYSQL_HOST" >> $GITHUB_OUTPUT

      - name: Display Service URLs
        run: |
          echo "# ğŸŒ Services disponibles" > services-urls.txt
          echo "" >> services-urls.txt
          echo "## ğŸš€ API REST (univ-soa)" >> services-urls.txt
          echo "- URL: ${{ steps.services.outputs.api_url }}" >> services-urls.txt
          echo "- Health Check: ${{ steps.services.outputs.api_url }}/actuator/health" >> services-urls.txt
          echo "- Database Test: ${{ steps.services.outputs.api_url }}/api/database/test" >> services-urls.txt
          echo "" >> services-urls.txt
          echo "## ğŸ—„ï¸ phpMyAdmin" >> services-urls.txt
          echo "- URL: ${{ steps.services.outputs.phpmyadmin_url }}" >> services-urls.txt
          echo "- Username: root" >> services-urls.txt
          echo "- Password: password" >> services-urls.txt
          echo "" >> services-urls.txt
          echo "## ğŸ¬ MySQL Database (internal)" >> services-urls.txt
          echo "- Host: ${{ steps.services.outputs.mysql_host }}" >> services-urls.txt
          echo "- Port: 3306" >> services-urls.txt
          echo "- Database: testdb" >> services-urls.txt
          echo "- Username: root" >> services-urls.txt
          echo "- Password: password" >> services-urls.txt
          
          echo ""
          echo "ğŸ“‹ Services URLs:"
          cat services-urls.txt

      - name: Upload services URLs artifact
        uses: actions/upload-artifact@v4
        with:
          name: services-urls
          path: services-urls.txt
          retention-days: 7

      - name: Test API health
        run: |
          echo "ğŸ§ª Testing API health..."
          curl -f "${{ steps.services.outputs.api_url }}/actuator/health" || echo "âš ï¸ API not reachable"

      - name: Test phpMyAdmin
        run: |
          echo "ğŸ§ª Testing phpMyAdmin..."
          curl -f "${{ steps.services.outputs.phpmyadmin_url }}" || echo "âš ï¸ phpMyAdmin not reachable"

