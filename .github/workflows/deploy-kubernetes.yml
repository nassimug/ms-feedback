name: CD - Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        type: string
      microservice-name:
        description: 'Microservice name'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag'
        required: true
        type: string
    secrets:
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_KUBECONFIG:
        required: true
      OKE_CLUSTER_ID:
        required: true
      OCI_CLI_USER:
        required: false
      OCI_CLI_FINGERPRINT:
        required: false
      OCI_CLI_TENANCY:
        required: false
      OCI_CLI_REGION:
        required: false
      OCI_API_KEY:
        required: false
      MYSQL_HOST:
        required: true
      MYSQL_USER:
        required: true
      MYSQL_PASSWORD:
        required: true
      MYSQL_ROOT_PASSWORD:
        required: true
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - integration
          - production
        default: integration
      image-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      NAMESPACE: ${{ inputs.namespace }}
      MICROSERVICE_NAME: ${{ inputs.microservice-name }}
      IMAGE_TAG: ${{ inputs.image-tag }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION || 'eu-paris-1' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          mkdir -p ~/.kube
          
          # D√©coder et sauvegarder le kubeconfig depuis le secret base64
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√© depuis OCI_KUBECONFIG"
          
          # Afficher les informations du cluster (sans donn√©es sensibles)
          echo "Informations du cluster:"
          CLUSTER_SERVER=$(grep 'server:' ~/.kube/config | head -1 | awk '{print $2}' | sed 's/https:\/\///')
          echo "  Server: $CLUSTER_SERVER"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          echo "V√©rification du namespace '${{ env.NAMESPACE }}'..."
          
          if kubectl get namespace "${{ env.NAMESPACE }}" &> /dev/null; then
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '${{ env.NAMESPACE }}'..."
            kubectl create namespace "${{ env.NAMESPACE }}"
            kubectl label namespace "${{ env.NAMESPACE }}" environment=${{ inputs.environment }}
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' cr√©√©"
          fi

      - name: Create or Update Secrets
        run: |
          echo "Configuration des secrets..."
          
          # Variables pour le secret OCIR
          DOCKER_SERVER="fra.ocir.io"
          DOCKER_USERNAME="${{ secrets.OCI_TENANCY_NAMESPACE }}/${{ secrets.OCI_USERNAME }}"
          DOCKER_PASSWORD="${{ secrets.OCI_AUTH_TOKEN }}"
          
          echo "Registry: $DOCKER_SERVER"
          echo "Username: ${DOCKER_USERNAME%%/*}/***"
          
          # V√©rifier que les variables sont d√©finies
          if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_PASSWORD" ]; then
            echo "‚ùå Erreur: OCI_TENANCY_NAMESPACE, OCI_USERNAME ou OCI_AUTH_TOKEN manquant"
            exit 1
          fi
          
          # Secret OCIR
          kubectl create secret docker-registry ocir-secret \
            --docker-server="$DOCKER_SERVER" \
            --docker-username="$DOCKER_USERNAME" \
            --docker-password="$DOCKER_PASSWORD" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secret OCIR configur√©"
          
          # Secret MySQL
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets MySQL configur√©s"

      - name: Create or Update ConfigMap
        run: |
          echo "Configuration de la ConfigMap..."
          
          SPRING_PROFILE="${{ inputs.environment }}"
          LOG_LEVEL="DEBUG"
          LOG_LEVEL_JDBC="DEBUG"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE="$SPRING_PROFILE" \
            --from-literal=LOG_LEVEL="$LOG_LEVEL" \
            --from-literal=LOG_LEVEL_JDBC="$LOG_LEVEL_JDBC" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap configur√©e"

      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Variables pour le template
          export MICROSERVICE_NAME="${{ env.MICROSERVICE_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export VERSION="${{ env.IMAGE_TAG }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          export IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}"
          
          # D√©terminer le nombre de replicas selon l'environnement
          if [ "${{ inputs.environment }}" == "production" ]; then
            export REPLICAS=2
          else
            export REPLICAS=1
          fi
          
          echo "Configuration du d√©ploiement:"
          echo "  - Microservice: $MICROSERVICE_NAME"
          echo "  - Namespace: $NAMESPACE"
          echo "  - Image: $IMAGE_URL:$IMAGE_TAG"
          echo "  - Replicas: $REPLICAS"
          
          # G√©n√©rer et appliquer le d√©ploiement
          envsubst < k8s/oci/deployment-template.yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          kubectl rollout status deployment/${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=50 || true
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment ${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç √âv√©nements r√©cents :"
            kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
            exit 1
          }
          
          echo "‚úÖ D√©ploiement r√©ussi"

      - name: Display Deployment Info
        run: |
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Microservice: ${{ env.MICROSERVICE_NAME }}"
          echo "üè∑Ô∏è  Image: cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "üåç Namespace: ${{ env.NAMESPACE }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üìù LOGS DES PODS (derni√®res 20 lignes)"
          echo "=========================================="
          kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=20 || true
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi