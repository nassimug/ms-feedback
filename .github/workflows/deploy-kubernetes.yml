name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: univ-soa
  NAMESPACE: soa-integration

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube (manual installation)
        run: |
          echo "ðŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          echo "ðŸš€ Starting Minikube..."
          minikube start --driver=docker --memory=4096 --cpus=2 --kubernetes-version=v1.28.0
          
          echo "â³ Waiting for Minikube to be ready..."
          minikube status
          
          echo "âœ… Minikube started successfully"

      - name: Configure kubectl
        run: |
          echo "ðŸ”§ Configuring kubectl..."
          kubectl config use-context minikube
          kubectl config view
          
          echo "âœ… kubectl configured"

      - name: Verify Minikube
        run: |
          echo "ðŸ” Cluster info:"
          kubectl cluster-info
          
          echo "ðŸ“Š Nodes:"
          kubectl get nodes
          
          echo "ðŸ³ Docker env:"
          minikube docker-env

      - name: Load Docker image into Minikube
        run: |
          echo "ðŸ³ Configuring Docker to use Minikube's daemon..."
          eval $(minikube docker-env)
          
          echo "ðŸ“¥ Loading Docker image..."
          docker load -i app-image.tar
          
          echo "ðŸ·ï¸ Tagging image as latest for Kubernetes..."
          docker tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "ðŸ“‹ Available images in Minikube:"
          docker images | grep ${{ env.IMAGE_NAME }}
          
          echo "âœ… Image loaded and tagged successfully"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace created/verified"

      - name: Deploy application to Minikube
        run: |
          echo "ðŸš€ Deploying manifests..."
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "ðŸ“Š Current deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}

      - name: Update deployment image
        run: |
          echo "ðŸ·ï¸ Updating deployment with image: ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }}"
          kubectl set image deployment/univ-soa \
            univ-soa=${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} \
            -n ${{ env.NAMESPACE }}
          echo "âœ… Deployment updated"

      - name: Debug pods before rollout
        if: always()
        run: |
          echo "ðŸ”— Verifying kubectl connection..."
          kubectl cluster-info || {
            echo "âŒ kubectl not connected to cluster!"
            echo "Attempting to reconfigure..."
            kubectl config use-context minikube
            minikube update-context
          }
          
          echo "ðŸ” Pod status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide || echo "No pods found yet"
          
          echo "ðŸ” Deployment description:"
          kubectl describe deployment univ-soa -n ${{ env.NAMESPACE }} || echo "Deployment not found yet"
          
          echo "ðŸ” Events:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' || echo "No events yet"

      - name: Wait for deployment
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/univ-soa -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "âŒ Rollout timeout! Gathering debug info..."
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }}
            kubectl logs -l app=univ-soa -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          
          echo "âœ… Deployment successful"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide

      - name: Get service endpoint
        id: endpoint
        run: |
          kubectl wait --for=condition=ready pod -l app=univ-soa -n ${{ env.NAMESPACE }} --timeout=300s
          SERVICE_URL=$(minikube service univ-soa --url -n ${{ env.NAMESPACE }} 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            MINIKUBE_IP=$(minikube ip)
            NODEPORT=$(kubectl get svc univ-soa -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
            SERVICE_URL="http://$MINIKUBE_IP:$NODEPORT"
          fi
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service accessible at: $SERVICE_URL"

      - name: Test service health
        run: |
          curl -f ${{ steps.endpoint.outputs.service_url }}/actuator/health || \
          curl -f ${{ steps.endpoint.outputs.service_url }}/health || \
          curl -f ${{ steps.endpoint.outputs.service_url }}/ || \
          echo "Health check endpoint not available"

      - name: Upload service URL artifact
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 1

