name: CD - Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        type: string
      microservice-name:
        description: 'Microservice name'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag'
        required: true
        type: string
    secrets:
      OCI_KUBECONFIG:
        required: true
      OKE_CLUSTER_ID:
        required: false
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      MYSQL_HOST:
        required: false
      MYSQL_USER:
        required: false
      MYSQL_PASSWORD:
        required: false
      MYSQL_ROOT_PASSWORD:
        required: false
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - integration
          - production
        default: integration
      image-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: BACKEND_ENVIRONMENT
    env:
      NAMESPACE: ${{ inputs.namespace }}
      MICROSERVICE_NAME: ${{ inputs.microservice-name }}
      IMAGE_TAG: ${{ inputs.image-tag }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION || 'eu-paris-1' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          mkdir -p ~/.kube
          
          
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√© depuis OCI_KUBECONFIG"
          
          echo "Informations du cluster:"
          CLUSTER_SERVER=$(grep 'server:' ~/.kube/config | head -1 | awk '{print $2}' | sed 's/https:\/\///')
          echo "  Server: $CLUSTER_SERVER"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          echo "V√©rification du namespace '${{ env.NAMESPACE }}'..."
          
          if kubectl get namespace "${{ env.NAMESPACE }}" &> /dev/null; then
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '${{ env.NAMESPACE }}'..."
            kubectl create namespace "${{ env.NAMESPACE }}"
            kubectl label namespace "${{ env.NAMESPACE }}" environment=${{ inputs.environment }}
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' cr√©√©"
          fi

      - name: Create or Update Secrets
        run: |
          echo "Configuration des secrets..."
          
          # Variables pour le secret OCIR
          DOCKER_SERVER="cdg.ocir.io"
          OCI_TENANCY_NAMESPACE="${{ secrets.OCI_TENANCY_NAMESPACE }}"
          OCI_USERNAME="${{ secrets.OCI_USERNAME }}"
          OCI_AUTH_TOKEN="${{ secrets.OCI_AUTH_TOKEN }}"
          
          # V√©rifier que les variables sont d√©finies
          if [ -z "$OCI_TENANCY_NAMESPACE" ] || [ -z "$OCI_USERNAME" ] || [ -z "$OCI_AUTH_TOKEN" ]; then
            echo "‚ùå Erreur: Secrets manquants"
            echo "OCI_TENANCY_NAMESPACE: $([ -z "$OCI_TENANCY_NAMESPACE" ] && echo 'VIDE ‚ùå' || echo 'OK ‚úÖ')"
            echo "OCI_USERNAME: $([ -z "$OCI_USERNAME" ] && echo 'VIDE ‚ùå' || echo 'OK ‚úÖ')"
            echo "OCI_AUTH_TOKEN: $([ -z "$OCI_AUTH_TOKEN" ] && echo 'VIDE ‚ùå' || echo 'OK ‚úÖ')"
            exit 1
          fi
          
          # Le username doit avoir le format: <tenancy-namespace>/<username>
          DOCKER_USERNAME="${OCI_TENANCY_NAMESPACE}/${OCI_USERNAME}"
          DOCKER_PASSWORD="$OCI_AUTH_TOKEN"
          
          echo "Registry: $DOCKER_SERVER"
          echo "Username format: <namespace>/<user>"
          echo "Longueur namespace: ${#OCI_TENANCY_NAMESPACE} caract√®res"
          echo "Longueur username: ${#OCI_USERNAME} caract√®res"
          echo "Longueur token: ${#OCI_AUTH_TOKEN} caract√®res"
          
          # Test de connexion OCIR avant de cr√©er le secret
          echo ""
          echo "Test de connexion √† OCIR..."
          if echo "$DOCKER_PASSWORD" | docker login "$DOCKER_SERVER" -u "$DOCKER_USERNAME" --password-stdin 2>&1; then
            echo "‚úÖ Connexion OCIR r√©ussie"
          else
            echo ""
            echo "‚ùå √âCHEC DE CONNEXION √Ä OCIR"
            echo ""
            echo "CAUSE PROBABLE:"
            echo "‚Ä¢ OCI_TENANCY_NAMESPACE incorrect dans les secrets GitHub"
            echo "  Valeur attendue: 'axfuowvuxal7' (13 caract√®res, avec 'f' apr√®s 'ax')"
            echo "  Longueur actuelle: ${#OCI_TENANCY_NAMESPACE} caract√®res"
            echo ""
            echo "‚Ä¢ OCI_USERNAME doit √™tre votre email complet"
            echo "  Format: 'abdelmoughitboutchi4@gmail.com'"
            echo ""
            echo "‚Ä¢ OCI_AUTH_TOKEN doit √™tre valide (20 caract√®res environ)"
            echo "  Longueur actuelle: ${#OCI_AUTH_TOKEN} caract√®res"
            echo ""
            echo "ACTION REQUISE:"
            echo "1. V√©rifiez OCI_TENANCY_NAMESPACE dans GitHub Secrets"
            echo "2. V√©rifiez que l'Auth Token est actif: Console OCI > User Settings > Auth Tokens"
            echo "3. Assurez-vous d'avoir les permissions IAM pour OCIR"
            echo ""
            exit 1
          fi
          
          # Secret OCIR
          kubectl create secret docker-registry ocir-secret \
            --docker-server="$DOCKER_SERVER" \
            --docker-username="$DOCKER_USERNAME" \
            --docker-password="$DOCKER_PASSWORD" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secret OCIR configur√©"
          
          # Secret MySQL
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets MySQL configur√©s"

      - name: Create or Update ConfigMap
        run: |
          echo "Configuration de la ConfigMap..."
          
          SPRING_PROFILE="${{ inputs.environment }}"
          LOG_LEVEL="DEBUG"
          LOG_LEVEL_JDBC="DEBUG"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE="$SPRING_PROFILE" \
            --from-literal=LOG_LEVEL="$LOG_LEVEL" \
            --from-literal=LOG_LEVEL_JDBC="$LOG_LEVEL_JDBC" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap configur√©e"


      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Sanitiser le nom du microservice (remplacer les points par des tirets)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          # Variables pour le template
          export MICROSERVICE_NAME="$MICROSERVICE_NAME_SANITIZED"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export VERSION="${{ env.IMAGE_TAG }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          export IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/$MICROSERVICE_NAME_SANITIZED"
          
          # D√©terminer le nombre de replicas selon l'environnement
          if [ "${{ inputs.environment }}" == "production" ]; then
            export REPLICAS=2
          else
            export REPLICAS=1
          fi
          
          echo "Configuration du d√©ploiement:"
          echo "  - Microservice original: ${{ env.MICROSERVICE_NAME }}"
          echo "  - Microservice sanitized: $MICROSERVICE_NAME_SANITIZED"
          echo "  - Namespace: $NAMESPACE"
          echo "  - Image: $IMAGE_URL:$IMAGE_TAG"
          echo "  - Replicas: $REPLICAS"
          
          # G√©n√©rer et appliquer le d√©ploiement
          envsubst < k8s/oci/deployment-template.yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          # Sanitiser le nom du microservice (m√™me transformation)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          kubectl rollout status deployment/$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --tail=50 || true
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment $MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }}
            exit 1
          }
          
          echo "‚úÖ D√©ploiement termin√© avec succ√®s"

      - name: Display Deployment Info
        run: |
          # Sanitiser le nom du microservice (m√™me transformation)
          MICROSERVICE_NAME_SANITIZED=$(echo "${{ env.MICROSERVICE_NAME }}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Microservice original: ${{ env.MICROSERVICE_NAME }}"
          echo "üè∑Ô∏è  Microservice sanitized: $MICROSERVICE_NAME_SANITIZED"
          echo "üè∑Ô∏è  Image: cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/$MICROSERVICE_NAME_SANITIZED:${{ env.IMAGE_TAG }}"
          echo "üåç Namespace: ${{ env.NAMESPACE }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n ${{ env.NAMESPACE }} -l app=$MICROSERVICE_NAME_SANITIZED
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=$MICROSERVICE_NAME_SANITIZED
          echo ""
          echo "=========================================="
          echo "üìù LOGS DES PODS (derni√®res 20 lignes)"
          echo "=========================================="
          kubectl logs -l app=$MICROSERVICE_NAME_SANITIZED -n ${{ env.NAMESPACE }} --tail=20 || true
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi