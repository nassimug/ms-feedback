name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: ms-feedback
  NAMESPACE: ms-feedback

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube (manual installation)
        run: |
          echo "ðŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          echo "ðŸš€ Starting Minikube..."
          minikube start --driver=docker --memory=4096 --cpus=2 --kubernetes-version=v1.28.0
          
          echo "â³ Waiting for Minikube to be ready..."
          minikube status
          
          echo "âœ… Minikube started successfully"

      - name: Configure kubectl
        run: |
          echo "ðŸ”§ Configuring kubectl..."
          kubectl config use-context minikube
          kubectl config view
          
          echo "âœ… kubectl configured"

      - name: Verify Minikube
        run: |
          echo "ðŸ” Cluster info:"
          kubectl cluster-info
          
          echo "ðŸ“Š Nodes:"
          kubectl get nodes
          
          echo "ðŸ³ Docker env:"
          minikube docker-env

      - name: Load Docker image into Minikube
        run: |
          echo "ðŸ“¥ Loading Docker image into Minikube..."
          minikube image load app-image.tar
          
          echo "ðŸ·ï¸ Tagging image inside Minikube..."
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "ðŸ“‹ Images inside Minikube:"
          minikube image ls | grep ${{ env.IMAGE_NAME }} || echo "âš ï¸  Image not found yet, will retry..."
          
          echo "âœ… Image loaded and tagged successfully"

      - name: Pull and Load MS-Persistance image
        run: |
          echo "ðŸ“¥ Pulling MS-Persistance image directly into Minikube..."
          eval $(minikube -p minikube docker-env)
          docker pull abdboutchichi/ms-persistance:latest
          echo "ðŸ” Verifying MS-Persistance image in Minikube..."
          docker images | grep ms-persistance || { echo "âŒ ms-persistance image not found"; exit 1; }
          echo "âœ… MS-Persistance image successfully loaded into Minikube"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace created/verified"

      - name: Deploy application to Minikube
        run: |
          echo "ðŸš€ Deploying manifests..."
          kubectl apply -f k8s/minikube/persistance.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "ðŸ“Š Current deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo "âœ… Manifests applied (ms-persistance + ms-feedback)"

      - name: Wait for pods to be created
        run: |
          echo "â³ Waiting 15 seconds for pods to be created..."
          sleep 15
          
          echo "ðŸ“Š Current state:"
          kubectl get all -n ${{ env.NAMESPACE }}

      - name: Wait for MySQL to be ready
        run: |
          echo "â³ Waiting for MySQL to be ready (max 120s)..."
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=120s || {
            echo "âŒ MySQL not ready!"
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=mysql
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          echo "âœ… MySQL is ready!"

      - name: Deploy phpMyAdmin
        run: |
          echo "ðŸ¬ Deploying phpMyAdmin..."
          kubectl apply -f k8s/minikube/phpmyadmin.yaml -n ${{ env.NAMESPACE }}
          
          echo "â³ Waiting for phpMyAdmin to be ready..."
          kubectl wait --for=condition=ready pod -l app=phpmyadmin -n ${{ env.NAMESPACE }} --timeout=60s || {
            echo "âš ï¸ phpMyAdmin not ready, but continuing..."
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=phpmyadmin
          }
          echo "âœ… phpMyAdmin deployed!"

      - name: Debug pods before rollout
        if: always()
        run: |
          echo "ðŸ” Current pods status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "ðŸ” ms-feedback pods details:"
          kubectl describe pods -l app=ms-feedback -n ${{ env.NAMESPACE }} || echo "No ms-feedback pods yet"
          
          echo ""
          echo "ðŸ” Recent events:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' --field-selector type!=Normal | tail -20 || echo "No error events"

      - name: Wait for deployment
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/ms-feedback -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "âŒ Rollout timeout! Gathering debug info..."
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }}
            kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          
          echo "âœ… Deployment successful"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide

      - name: Get service endpoint
        id: endpoint
        run: |
          kubectl wait --for=condition=ready pod -l app=ms-feedback -n ${{ env.NAMESPACE }} --timeout=300s
          SERVICE_URL=$(minikube service ms-feedback --url -n ${{ env.NAMESPACE }} 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            MINIKUBE_IP=$(minikube ip)
            NODEPORT=$(kubectl get svc ms-feedback -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
            SERVICE_URL="http://$MINIKUBE_IP:$NODEPORT"
          fi
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service accessible at: $SERVICE_URL"

      - name: Test service health
        run: |
          echo "ðŸ¥ Testing service health..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          # Attendre que le service soit vraiment prÃªt
          for i in {1..12}; do
            if curl -f --connect-timeout 5 "$SERVICE_URL/actuator/health" 2>/dev/null; then
              echo "âœ… Service is healthy!"
              break
            fi
            echo "â³ Waiting for service to be fully ready ($i/12)..."
            sleep 5
          done
          
          # Test final
          curl -f "$SERVICE_URL/actuator/health" || \
          curl -f "$SERVICE_URL/health" || \
          curl -f "$SERVICE_URL/" || {
            echo "âŒ Health check failed"
            kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=50
            exit 1
          }
          
          echo "âœ… Service is healthy and ready for tests"

      - name: Install Newman for integration tests
        working-directory: ./tests/newman
        run: |
          echo "ðŸ“¦ Installing Newman dependencies..."
          npm install
          echo "âœ… Newman installed"

      - name: Configure Newman environment
        working-directory: ./tests/newman
        run: |
          echo "ðŸ“ Configuring Newman with service URL..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          # Compute MS-Persistance URL (NodePort 30090)
          MINIKUBE_IP=$(echo $SERVICE_URL | sed -E 's|http://([^:]+):.*|\1|')
          PERSISTANCE_URL="http://${MINIKUBE_IP}:30090"
          echo "ðŸ”— ms-feedback URL: $SERVICE_URL"
          echo "ðŸ”— ms-persistance URL: $PERSISTANCE_URL"
          
          jq --arg url "$SERVICE_URL" --arg purl "$PERSISTANCE_URL" \
            '(.values[] | select(.key == "baseUrl") | .value) = $url |
             (.values[] | select(.key == "persistanceUrl") | .value) = $purl' \
            env.json > env.tmp.json
          
          echo "ðŸ“‹ Environment configuration:"
          cat env.tmp.json | jq '.'
          echo "âœ… Environment configured with URLs"

      - name: Run Newman integration tests
        working-directory: ./tests/newman
        run: |
          echo "ðŸš€ Starting Newman integration tests..."
          echo "ðŸŽ¯ Target: ${{ steps.endpoint.outputs.service_url }}"
          
          mkdir -p newman-results
          
          npx newman run ./collection.json \
            --environment ./env.tmp.json \
            --iteration-data ./dataset.json \
            --reporters cli,json \
            --reporter-json-export ./newman-results/newman-report.json \
            --timeout-request 30000 \
            --bail || {
              echo "âŒ Newman tests failed!"
              echo ""
              echo "ðŸ“Š Service status:"
              curl -v "${{ steps.endpoint.outputs.service_url }}/actuator/health" || true
              echo ""
              echo "ðŸ“‹ Pod logs:"
              kubectl logs -l app=ms-feedback -n ${{ env.NAMESPACE }} --tail=100
              exit 1
            }
          
          echo ""
          echo "âœ… All Newman tests passed successfully!"

      - name: Upload Newman results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-results
          path: tests/newman/newman-results/
          retention-days: 7

      - name: Upload service URL artifact
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 1
