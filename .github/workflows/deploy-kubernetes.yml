name: Déploiement Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: "Environnement cible (integration/production)"
        required: true
        type: string
      namespace:
        description: "Namespace Kubernetes"
        required: true
        type: string
      microservice-name:
        description: "Nom du microservice"
        required: true
        type: string
      image-tag:
        description: "Tag de l'image Docker"
        required: true
        type: string
    secrets:
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_KUBECONFIG:
        required: true
      OCI_CLI_USER:
        required: false
      OCI_CLI_FINGERPRINT:
        required: false
      OCI_CLI_TENANCY:
        required: false
      OCI_CLI_REGION:
        required: false
      OCI_CLI_KEY_CONTENT:
        required: false
      MYSQL_HOST:
        required: false
      MYSQL_USER:
        required: false
      MYSQL_PASSWORD:
        required: false
      MYSQL_ROOT_PASSWORD:
        required: false

env:
  OCI_REGION: eu-paris-1
  OCI_REGISTRY: cdg.ocir.io

jobs:
  deploy:
    name: Déployer sur ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Install OCI CLI
        run: |
          echo "Installation d'OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install-oci-cli.sh
          bash install-oci-cli.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
          
          # Vérifier l'installation
          ~/bin/oci --version

      - name: Configure OCI CLI
        if: secrets.OCI_CLI_USER != ''
        run: |
          echo "Configuration d'OCI CLI..."
          mkdir -p ~/.oci
          chmod 700 ~/.oci
          
          # Créer le fichier de configuration
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=${{ secrets.OCI_CLI_USER }}
          fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_CLI_TENANCY }}
          region=${{ secrets.OCI_CLI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          EOF
          
          chmod 600 ~/.oci/config
          
          # Créer la clé privée
          echo "${{ secrets.OCI_CLI_KEY_CONTENT }}" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          
          echo "✅ OCI CLI configuré"

      - name: Configure OKE Kubernetes context
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          
          echo "Vérification de la connexion au cluster..."
          kubectl cluster-info
          kubectl get nodes

      - name: Créer le namespace si nécessaire
        run: |
          kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace ${{ inputs.namespace }} environment=${{ inputs.environment }} --overwrite

      - name: Créer le Secret pour OCIR
        run: |
          echo "Configuration du secret OCIR pour Kubernetes..."
          
          # Construire le username complet si nécessaire
          OCI_USERNAME="${{ secrets.OCI_USERNAME }}"
          OCI_TENANCY_NAMESPACE="${{ secrets.OCI_TENANCY_NAMESPACE }}"
          
          # Si l'username ne contient pas le tenancy namespace, on l'ajoute
          if [[ "$OCI_USERNAME" != *"/"* ]]; then
            FULL_USERNAME="${OCI_TENANCY_NAMESPACE}/${OCI_USERNAME}"
            echo "⚠️  Username modifié pour inclure le tenancy: $FULL_USERNAME"
          else
            FULL_USERNAME="$OCI_USERNAME"
            echo "✅ Username déjà au bon format: $FULL_USERNAME"
          fi
          
          # Créer le secret Docker Registry
          kubectl create secret docker-registry ocir-secret \
            --docker-server=${{ env.OCI_REGISTRY }} \
            --docker-username="$FULL_USERNAME" \
            --docker-password="${{ secrets.OCI_AUTH_TOKEN }}" \
            --namespace=${{ inputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ Secret OCIR créé dans le namespace ${{ inputs.namespace }}"

      - name: Appliquer les secrets MySQL
        run: |
          envsubst < k8s/oci/mysql-secrets.yaml | kubectl apply -f -
        env:
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}

      - name: Appliquer les ConfigMaps
        run: |
          kubectl apply -f k8s/oci/configmap.yaml

      - name: Préparer les valeurs Helm
        id: helm-values
        run: |
          TENANCY_NAMESPACE="${{ secrets.OCI_TENANCY_NAMESPACE }}"
          IMAGE_REPO="${{ env.OCI_REGISTRY }}/${TENANCY_NAMESPACE}/smartdish/${{ inputs.microservice-name }}"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            DOMAIN="smartdish.cloud"
            REPLICAS=2
            VALUES_FILE="values-production.yaml"
          else
            DOMAIN="smartdish-integration.cloud"
            REPLICAS=1
            VALUES_FILE="values-integration.yaml"
          fi
          
          FULL_DOMAIN="soa-${{ inputs.microservice-name }}.${DOMAIN}"
          
          echo "IMAGE_REPO=${IMAGE_REPO}" >> $GITHUB_OUTPUT
          echo "FULL_DOMAIN=${FULL_DOMAIN}" >> $GITHUB_OUTPUT
          echo "REPLICAS=${REPLICAS}" >> $GITHUB_OUTPUT
          echo "VALUES_FILE=${VALUES_FILE}" >> $GITHUB_OUTPUT
          
          echo "Image: ${IMAGE_REPO}:${{ inputs.image-tag }}"
          echo "Domaine: ${FULL_DOMAIN}"
          echo "Replicas: ${REPLICAS}"
          echo "Values file: ${VALUES_FILE}"

      - name: Déployer avec Helm
        run: |
          helm upgrade --install ${{ inputs.microservice-name }} ./helm/smartdish \
            --namespace ${{ inputs.namespace }} \
            --create-namespace \
            --values ./helm/smartdish/${{ steps.helm-values.outputs.VALUES_FILE }} \
            --set image.repository=${{ steps.helm-values.outputs.IMAGE_REPO }} \
            --set image.tag=${{ inputs.image-tag }} \
            --set microserviceName=${{ inputs.microservice-name }} \
            --set ingress.hosts[0].host=${{ steps.helm-values.outputs.FULL_DOMAIN }} \
            --set replicaCount=${{ steps.helm-values.outputs.REPLICAS }} \
            --wait \
            --timeout 5m

      - name: Vérifier le déploiement
        run: |
          echo "Attente du déploiement..."
          kubectl rollout status deployment/${{ inputs.microservice-name }} -n ${{ inputs.namespace }} --timeout=5m
          
          echo ""
          echo "Pods en cours d'execution:"
          kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=smartdish-microservice
          
          echo ""
          echo "Services:"
          kubectl get svc -n ${{ inputs.namespace }} -l app.kubernetes.io/name=smartdish-microservice
          
          echo ""
          echo "Ingress:"
          kubectl get ingress -n ${{ inputs.namespace }}
          
          echo ""
          echo "URL d'acces: https://${{ steps.helm-values.outputs.FULL_DOMAIN }}"
            enabled: true
            role: ${{ steps.helm-values.outputs.VAULT_ROLE }}
            path: secret/data/${{ inputs.environment }}/${{ inputs.microservice-name }}
          
          app:
            javaOpts: "-Xmx${{ steps.helm-values.outputs.MEMORY_REQUEST }} -Xms128m"
            profile: "${{ inputs.environment }}"
            timezone: "Europe/Paris"
          
          healthCheck:
            enabled: true
            livenessProbe:
              httpGet:
                path: /actuator/health/liveness
                port: 8080
              initialDelaySeconds: 60
              periodSeconds: 10
              timeoutSeconds: 5
              failureThreshold: 3
            readinessProbe:
              httpGet:
                path: /actuator/health/readiness
                port: 8080
              initialDelaySeconds: 30
              periodSeconds: 5
              timeoutSeconds: 3
              failureThreshold: 3
          
          serviceAccount:
            create: true
            name: ${{ inputs.microservice-name }}-sa
          EOF
          
          echo "Configuration Helm créée:"
          cat custom-values.yaml

      - name: Déployer avec Helm
        run: |
          helm upgrade --install ${{ inputs.microservice-name }} ./.github/helm/chart \
            --namespace=${{ inputs.namespace }} \
            --create-namespace \
            --values custom-values.yaml \
            --wait \
            --timeout=10m \
            --atomic

      - name: Vérifier le déploiement
        run: |
          echo "Attente du déploiement..."
          kubectl rollout status deployment/${{ inputs.microservice-name }} -n ${{ inputs.namespace }} --timeout=5m
          
          echo ""
          echo "État des pods:"
          kubectl get pods -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }}
          
          echo ""
          echo "Service exposé:"
          kubectl get service ${{ inputs.microservice-name }} -n ${{ inputs.namespace }}
          
          echo ""
          echo "Ingress configuré:"
          kubectl get ingress -n ${{ inputs.namespace }}
          
          echo ""
          echo "Certificat TLS:"
          kubectl get certificate -n ${{ inputs.namespace }} ${{ inputs.microservice-name }}-tls || echo "Certificat en cours de création..."

      - name: Attendre le certificat SSL
        run: |
          echo "Attente de l'émission du certificat SSL..."
          for i in {1..30}; do
            STATUS=$(kubectl get certificate -n ${{ inputs.namespace }} ${{ inputs.microservice-name }}-tls -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")
            if [ "$STATUS" == "True" ]; then
              echo "Certificat SSL émis avec succès!"
              kubectl describe certificate -n ${{ inputs.namespace }} ${{ inputs.microservice-name }}-tls
              break
            fi
            echo "Tentative $i/30 - Certificat pas encore prêt..."
            sleep 10
          done

      - name: Test de santé
        run: |
          echo "Attente que le service soit accessible..."
          sleep 30
          
          HEALTH_URL="https://${{ steps.helm-values.outputs.FULL_DOMAIN }}/actuator/health"
          
          echo "Test de l'endpoint: $HEALTH_URL"
          
          for i in {1..20}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -k "$HEALTH_URL" || echo "000")
            if [ "$HTTP_CODE" == "200" ]; then
              echo "Service accessible et en bonne santé!"
              echo "Réponse du health check:"
              curl -k -s "$HEALTH_URL" | jq . || curl -k -s "$HEALTH_URL"
              exit 0
            fi
            echo "Tentative $i/20 - Code HTTP: $HTTP_CODE"
            sleep 15
          done
          
          echo "ATTENTION: Le service ne répond pas encore au health check"
          echo "Vérifiez manuellement: $HEALTH_URL"
          echo "Logs du pod:"
          kubectl logs -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }} --tail=50 || true

      - name: Récupérer les logs en cas d'échec
        if: failure()
        run: |
          echo "=== LOGS DES PODS ==="
          kubectl logs -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }} --tail=100 || true
          
          echo ""
          echo "=== DESCRIPTION DES PODS ==="
          kubectl describe pods -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }} || true
          
          echo ""
          echo "=== EVENTS DU NAMESPACE ==="
          kubectl get events -n ${{ inputs.namespace }} --sort-by='.lastTimestamp' | tail -20 || true
          
          echo ""
          echo "=== INGRESS DETAILS ==="
          kubectl describe ingress -n ${{ inputs.namespace }} || true
          
          echo ""
          echo "=== CERTIFICATE DETAILS ==="
          kubectl describe certificate -n ${{ inputs.namespace }} || true

      - name: Résumé du déploiement
        if: always()
        run: |
          echo "### Déploiement sur ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Paramètre | Valeur |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Microservice | \`${{ inputs.microservice-name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environnement | **${{ inputs.environment }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ inputs.namespace }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.helm-values.outputs.IMAGE_REPO }}:${{ inputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | [https://${{ steps.helm-values.outputs.FULL_DOMAIN }}](https://${{ steps.helm-values.outputs.FULL_DOMAIN }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | [/actuator/health](https://${{ steps.helm-values.outputs.FULL_DOMAIN }}/actuator/health) |" >> $GITHUB_STEP_SUMMARY
          echo "| Replicas | ${{ steps.helm-values.outputs.REPLICAS }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Resources | CPU: ${{ steps.helm-values.outputs.CPU_REQUEST }}/${{ steps.helm-values.outputs.CPU_LIMIT }}, Memory: ${{ steps.helm-values.outputs.MEMORY_REQUEST }}/${{ steps.helm-values.outputs.MEMORY_LIMIT }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Pods déployés" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }} >> $GITHUB_STEP_SUMMARY || echo "Impossible de récupérer les pods" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
